# Two-Bot Architecture with Unified Executors

## Overview

The system uses a **two-bot architecture** with specialized bots for different tasks:
1. **ActionPlanBot** - Handles all data operations (filter, sort, clean, formulas, etc.)
2. **ChartBot** - Handles all chart/visualization requests

Both bots generate structured JSON that is executed by specialized executors:
1. **PythonExecutor** - Executes Python code for data operations
2. **ChartExecutor** - Executes chart generation

## Architecture Flow

```
User Request
    ↓
LLMAgent (Router)
    ├─ Chart Request? → ChartBot → ChartExecutor → Chart Image
    └─ Data Operation? → ActionPlanBot → PythonExecutor → Modified DataFrame
```

## Components

### 1. LLMAgent (Router)
**File**: `services/llm_agent.py`

**Responsibilities**:
- Detects if request is for chart or data operation
- Routes to appropriate bot
- Returns unified response format

**Key Method**:
```python
def interpret_prompt(user_prompt, available_columns, ...) -> Dict:
    if self._is_chart_request(user_prompt):
        return self.chart_bot.generate_chart_plan(...)
    else:
        return self.action_plan_bot.generate_action_plan(...)
```

### 2. ActionPlanBot
**File**: `services/action_plan_bot.py`

**Responsibilities**:
- Generates Python code for ALL data operations
- Does NOT generate chart code (explicitly excluded)
- Returns JSON with `operations` array containing `python_code`

**Output Format**:
```json
{
  "operations": [
    {
      "python_code": "df = df.drop_duplicates().reset_index(drop=True)",
      "description": "Remove duplicate rows",
      "result_type": "dataframe"
    }
  ],
  "conditional_format": {...},
  "format": {...}
}
```

**Key Features**:
- Strict instruction: "DO NOT GENERATE CHARTS"
- Always generates `python_code` for operations
- Uses actual column names from dataset
- Supports: filter, sort, clean, formulas, transformations, etc.

### 3. ChartBot
**File**: `services/chart_bot.py`

**Responsibilities**:
- Generates chart configurations
- Identifies chart type and columns
- Returns chart configuration JSON

**Output Format**:
```json
{
  "chart_type": "bar|line|pie|histogram|scatter",
  "x_column": "ColumnName",
  "y_column": "ColumnName",
  "title": "Chart Title",
  "description": "Chart description"
}
```

**Key Features**:
- Analyzes dataset to identify appropriate columns
- Chooses chart type based on data and user request
- Validates columns exist in dataset
- Returns strict JSON format

### 4. PythonExecutor
**File**: `services/python_executor.py`

**Responsibilities**:
- Safely executes Python code generated by ActionPlanBot
- Handles all data operations: formulas, cleaning, filtering, sorting, etc.
- Provides execution environment with pandas, numpy, cleaning utilities

**Execution Environment**:
```python
{
    'df': DataFrame,
    'pd': pandas,
    'np': numpy,
    'DateCleaner': DateCleaner,
    'TextCleaner': TextCleaner,
    'CurrencyCleaner': CurrencyCleaner,
    # ... standard Python functions
}
```

**Key Features**:
- Code validation (no imports, no file operations, no system calls)
- Error handling with helpful messages
- Supports single operations and batch execution
- Tracks execution log and errors

**Usage**:
```python
executor = PythonExecutor(df)
result = executor.execute(python_code, operation_meta)
# or
executor.execute_multiple(operations)
```

### 5. ChartExecutor
**File**: `services/chart_executor.py`

**Responsibilities**:
- Executes chart generation based on ChartBot configuration
- Uses ChartBuilder to create chart images
- Validates columns exist before generation

**Key Features**:
- Validates chart configuration
- Uses ChartBuilder for actual chart creation
- Tracks chart paths and execution log
- Handles errors gracefully

**Usage**:
```python
executor = ChartExecutor(df)
chart_path = executor.execute(chart_config)
```

### 6. ExcelProcessor
**File**: `services/excel_processor.py`

**Responsibilities**:
- Orchestrates execution using both executors
- Handles conditional formatting and formatting (still uses existing methods)
- Returns unified result with dataframe, summary, chart_path, etc.

**Key Method**:
```python
def execute_action_plan(self, action_plan: Dict) -> Dict:
    # Handle charts
    if task == "chart" or "chart_config" in action_plan:
        chart_executor = ChartExecutor(self.df)
        chart_path = chart_executor.execute(chart_config)
    
    # Handle data operations
    operations = action_plan.get("operations", [])
    if operations:
        python_executor = PythonExecutor(self.df)
        execution_result = python_executor.execute_multiple(operations)
        self.df = python_executor.get_dataframe()
    
    # Handle conditional formatting (existing method)
    if "conditional_format" in action_plan:
        self._execute_conditional_format(action_plan)
    
    return {
        "df": self.df,
        "summary": self.summary,
        "chart_path": chart_path,
        "chart_needed": chart_path is not None,
        "chart_type": chart_type,
        "formula_result": self.formula_result
    }
```

## Request Flow Example

### Example 1: Data Operation
```
User: "Remove duplicates and filter rows where amount > 1000"

1. LLMAgent._is_chart_request() → False
2. Route to ActionPlanBot
3. ActionPlanBot generates:
   {
     "operations": [
       {
         "python_code": "df = df.drop_duplicates().reset_index(drop=True)",
         "description": "Remove duplicates"
       },
       {
         "python_code": "df = df[df['Amount'] > 1000].reset_index(drop=True)",
         "description": "Filter rows"
       }
     ]
   }
4. ExcelProcessor → PythonExecutor.execute_multiple()
5. PythonExecutor executes both operations sequentially
6. Returns modified dataframe
```

### Example 2: Chart Request
```
User: "Create a bar chart of revenue by country"

1. LLMAgent._is_chart_request() → True
2. Route to ChartBot
3. ChartBot generates:
   {
     "chart_type": "bar",
     "x_column": "Country",
     "y_column": "Revenue",
     "title": "Revenue by Country"
   }
4. ExcelProcessor → ChartExecutor.execute()
5. ChartExecutor uses ChartBuilder to create chart
6. Returns chart_path
```

## Benefits

1. **Separation of Concerns**: Data operations and charts are handled by specialized bots
2. **Better Accuracy**: Each bot has focused prompts for its domain
3. **Unified Execution**: All data operations use PythonExecutor (no task-specific methods)
4. **Maintainability**: Chart logic isolated from data operations
5. **Extensibility**: Easy to add new chart types or data operations
6. **Safety**: Code validation and restricted execution environment

## File Structure

```
backend/
├── services/
│   ├── llm_agent.py          # Router between bots
│   ├── action_plan_bot.py    # Data operations bot
│   ├── chart_bot.py          # Chart generation bot
│   ├── python_executor.py    # Python code executor
│   ├── chart_executor.py     # Chart executor
│   ├── excel_processor.py   # Main orchestrator
│   └── chart_builder.py      # Chart creation (existing)
└── app.py                    # API endpoint
```

## JSON Format Requirements

### ActionPlanBot Output
- **MUST** include `operations` array
- Each operation **MUST** have `python_code`
- Optional: `conditional_format`, `format`

### ChartBot Output
- **MUST** include `chart_type`, `x_column`, `y_column`, `title`
- `y_column` can be `null` for histograms
- All fields **MUST** use actual column names from dataset

## Error Handling

- **Code Validation**: PythonExecutor validates code before execution
- **Column Validation**: ChartExecutor validates columns exist
- **Execution Errors**: Both executors provide detailed error messages
- **Fallback**: ChartExecutor falls back to ChartBuilder if custom code fails

## Future Enhancements

1. Add more chart types (heatmap, box plot, etc.)
2. Support multiple charts in one request
3. Add chart customization options (colors, labels, etc.)
4. Enhance PythonExecutor with more utilities
5. Add execution caching for repeated operations

