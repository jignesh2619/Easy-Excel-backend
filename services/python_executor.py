"""
Python Executor

Robust executor for executing Python code generated by GPT-4.
Handles all data operations: formulas, cleaning, filtering, sorting, etc.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
from datetime import datetime, date, timedelta
import logging
import re
from services.cleaning.dates import DateCleaner
from services.cleaning.currency import CurrencyCleaner
from services.cleaning.text import TextCleaner

logger = logging.getLogger(__name__)


class PythonExecutor:
    """Robust Python code executor for Excel operations"""
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize executor with dataframe
        
        Args:
            df: DataFrame to operate on
        """
        self.df = df.copy()  # Work on copy
        self.original_df = df.copy()
        self.result = None
        self.execution_log: List[str] = []
        self.errors: List[str] = []
    
    def execute(self, python_code: str, operation_meta: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Execute Python code safely
        
        Args:
            python_code: Python code string to execute
            operation_meta: Optional metadata about the operation
        
        Returns:
            Dict with execution results
        """
        operation_meta = operation_meta or {}
        description = operation_meta.get("description", "Operation")
        result_type = operation_meta.get("result_type", "dataframe")
        
        # Step 1: Validate code
        validation_result = self._validate_code(python_code)
        if not validation_result["valid"]:
            error_msg = f"Code validation failed: {validation_result['error']}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Code validation failed for: {description}\nOriginal code: {python_code[:500]}")
            raise RuntimeError(error_msg)
        
        # Use cleaned code if available, otherwise use original
        code_to_execute = validation_result.get("cleaned_code", python_code)
        
        # Step 2: Prepare execution environment
        exec_globals = self._build_execution_environment()
        
        # Step 3: Execute code
        try:
            # Execute the cleaned code
            exec(code_to_execute, exec_globals)
            
            # Debug: Log extracted names and contacts if they exist
            if 'names' in exec_globals:
                names_list = exec_globals.get('names', [])
                logger.info(f"üîç Extracted names count: {len(names_list)}, sample: {names_list[:5] if len(names_list) > 0 else '[]'}")
            if 'contacts' in exec_globals:
                contacts_list = exec_globals.get('contacts', [])
                logger.info(f"üîç Extracted contacts count: {len(contacts_list)}, sample: {contacts_list[:5] if len(contacts_list) > 0 else '[]'}")
            
            # Step 4: Extract results
            result = self._extract_results(exec_globals, result_type)
            
            # Step 5: Update dataframe and normalize structure
            if 'df' in exec_globals:
                from services.dataframe_normalizer import normalize_dataframe
                self.df = normalize_dataframe(exec_globals['df'])
                
                # Debug: Log DataFrame state after execution
                if 'Student Name' in self.df.columns:
                    filled_student = self.df['Student Name'].notna().sum()
                    logger.info(f"üîç After execution - Student Name: {filled_student}/{len(self.df)} filled")
                if 'Contact No.' in self.df.columns:
                    filled_contact = self.df['Contact No.'].notna().sum()
                    logger.info(f"üîç After execution - Contact No.: {filled_contact}/{len(self.df)} filled")
            
            # Step 6: Store result
            if result is not None:
                self.result = result
            
            # Step 7: Log success
            self.execution_log.append(f"‚úì {description}")
            logger.info(f"Successfully executed: {description}")
            
            return {
                "success": True,
                "result": result,
                "description": description,
                "rows_affected": len(self.df),
                "columns": list(self.df.columns)
            }
            
        except NameError as e:
            error_msg = self._handle_name_error(e, python_code)
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except KeyError as e:
            error_str = str(e)
            # Check if this is a drop operation trying to drop non-existent columns
            # If so, handle gracefully (columns might have been dropped already or never created)
            if "drop" in python_code.lower() and ("not found in axis" in error_str or "not found" in error_str.lower()):
                # Extract column names from error if possible
                import re
                # Try to extract column names from error message
                col_match = re.search(r"\[(.*?)\]", error_str)
                if col_match:
                    missing_cols = col_match.group(1)
                    logger.warning(f"‚ö†Ô∏è Drop operation: Columns {missing_cols} not found, skipping drop (may have been dropped already or never created)")
                    self.execution_log.append(f"‚ö† {description}: Columns {missing_cols} not found, skipping (safe to ignore)")
                    # Return success since this is a cleanup operation
                    return {
                        "success": True,
                        "result": None,
                        "description": description,
                        "rows_affected": len(self.df),
                        "columns": list(self.df.columns),
                        "warning": f"Columns {missing_cols} not found, operation skipped"
                    }
            
            error_msg = f"Column not found: {str(e)}. Available columns: {list(self.df.columns)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except ValueError as e:
            error_str = str(e)
            # Check for the specific "Length of values does not match length of index" error
            if "Length of values" in error_str and "does not match length of index" in error_str:
                error_msg = f"Execution failed: {error_str}. This usually happens when trying to assign a list of values to a DataFrame row. When adding rows, create a dictionary with ONLY the columns you need, then use pd.concat([df, pd.DataFrame([new_row])], ignore_index=True). Example: new_row = {{'ColumnName': value}}; df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)"
            else:
                error_msg = f"Execution failed: {error_str}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except re.error as e:
            error_msg = f"Execution failed: Invalid regex pattern: {str(e)}. When removing or replacing special characters like *, ?, +, (, ), [, ], {{, }}, ^, $, |, \\, use regex=False. Example: df['Column'] = df['Column'].str.replace('*', '', regex=False)"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"Execution failed: {str(e)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
    
    def _build_execution_environment(self) -> Dict[str, Any]:
        """Build safe execution environment with all available resources"""
        return {
            # Data
            'df': self.df,
            'pd': pd,
            'np': np,
            'result': None,
            
            # Standard library modules
            're': re,
            
            # Date/Time
            'datetime': datetime,
            'date': date,
            'timedelta': timedelta,
            
            # Cleaning utilities
            'DateCleaner': DateCleaner,
            'CurrencyCleaner': CurrencyCleaner,
            'TextCleaner': TextCleaner,
            
            # Math functions
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'sum': sum,
            'pow': pow,
            
            # Type conversion
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            
            # String functions
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'range': range,
            
            # Common operations
            'any': any,
            'all': all,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'reversed': reversed,
            
            # Pandas helpers
            'isna': pd.isna,
            'notna': pd.notna,
            'concat': pd.concat,
            'merge': pd.merge,
        }
    
    def _clean_code(self, python_code: str) -> str:
        """
        Clean code - simplified to only essential fixes
        
        Args:
            python_code: Raw code string that might contain markdown
            
        Returns:
            Cleaned code string
        """
        code = python_code.strip()
        
        # 1. Replace literal \n escape sequences with actual newlines
        code = code.replace('\\n', '\n')
        
        # 2. Remove markdown code blocks
        if code.startswith('```'):
            lines = code.split('\n')
            if lines[0].startswith('```'):
                lines = lines[1:]
            if lines and lines[-1].strip() == '```':
                lines = lines[:-1]
            code = '\n'.join(lines)
        
        # Remove any remaining ``` markers
        code = re.sub(r'```[a-z]*\n?', '', code)
        
        # 3. Fix for/if statements on same line with semicolons (CRITICAL - Python syntax requirement)
        if ';' in code and (re.search(r';\s*for\s+\w+\s+in\s+', code) or re.search(r';\s*if\s+', code) or re.search(r';\s*elif\s+', code) or re.search(r';\s*else\s*:', code)):
            parts = []
            current_part = ''
            in_block = False
            
            for segment in code.split(';'):
                segment = segment.strip()
                if not segment:
                    continue
                
                # Check for control flow statements
                if re.match(r'(for|if|elif|else)\s+', segment) or re.match(r'else\s*:', segment):
                    if current_part:
                        parts.append(current_part)
                        current_part = ''
                    in_block = True
                    parts.append(segment)
                elif in_block:
                    parts.append('    ' + segment)  # Indent block body
                else:
                    current_part = current_part + '; ' + segment if current_part else segment
            
            if current_part:
                parts.append(current_part)
            code = '\n'.join(parts)
        
        # 4. Fix method chains split across lines (common LLM error)
        # Pattern: method()\n['key'] or method()\n.method2()
        # Join them back to single line
        lines = code.split('\n')
        fixed_lines = []
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            # Check if next line starts with [ or . (method chain continuation)
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line.startswith('[') or next_line.startswith('.'):
                    # Join them together
                    line = line + next_line
                    i += 1  # Skip next line since we merged it
            fixed_lines.append(line)
            i += 1
        code = '\n'.join(fixed_lines)
        
        # 5. Fix common syntax errors
        code = re.sub(r'\[None\)\*\(', '[None] * (', code)  # [None)*( -> [None] * (
        code = re.sub(r'\bgrouped\.co\b', 'grouped.columns', code)  # grouped.co -> grouped.columns
        code = re.sub(r'\bfor_in\b', 'for _ in', code)  # for_in -> for _ in
        code = re.sub(r'\bfor\s+_in\b', 'for _ in', code)  # for _in -> for _ in
        
        return code.strip()
    
    def _validate_code(self, python_code: str) -> Dict[str, Any]:
        """
        Validate code before execution - simplified
        
        Returns:
            {"valid": bool, "error": str, "cleaned_code": str}
        """
        # Clean the code first
        cleaned_code = self._clean_code(python_code)
        
        # Log the cleaned code for debugging
        logger.info(f"üîç Cleaned code (first 500 chars): {cleaned_code[:500]}")
        
        # Check if code is empty
        if not cleaned_code or not cleaned_code.strip():
            return {"valid": False, "error": "Code is empty after cleaning"}
        
        # Check 1: No import statements
        if re.search(r'\bimport\s+\w+|from\s+\w+\s+import', cleaned_code):
            return {"valid": False, "error": "Import statements are not allowed"}
        
        # Check 2: No dangerous operations
        dangerous_patterns = [
            r'\bopen\s*\(', r'\bread\s*\(', r'\bwrite\s*\(',
            r'__file__', r'__import__', r'eval\s*\(', r'exec\s*\(',
            r'\bos\.|sys\.|subprocess\.|shutil\.',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, cleaned_code):
                return {"valid": False, "error": f"Dangerous operation detected: {pattern}"}
        
        # Check 3: Basic syntax validation
        try:
            compile(cleaned_code, '<string>', 'exec')
        except SyntaxError as e:
            error_line = getattr(e, 'lineno', 'unknown')
            code_preview = cleaned_code[:300] if len(cleaned_code) > 300 else cleaned_code
            return {
                "valid": False, 
                "error": f"Syntax error at line {error_line}: {str(e)}\nCode preview:\n{code_preview}",
                "cleaned_code": cleaned_code
            }
        
        return {"valid": True, "error": None, "cleaned_code": cleaned_code}
    
    def _extract_results(self, exec_globals: Dict, result_type: str) -> Any:
        """Extract results from execution environment"""
        if result_type == "single_value":
            # Single value result (SUM, AVERAGE, etc.)
            if 'result' in exec_globals and exec_globals['result'] is not None:
                return exec_globals['result']
            return None
        
        elif result_type == "dataframe":
            # DataFrame operation (filter, sort, etc.)
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        elif result_type == "new_column":
            # New column created
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        return None
    
    def _handle_name_error(self, error: NameError, python_code: str) -> str:
        """Handle NameError with helpful messages"""
        error_str = str(error)
        
        # Extract the missing name
        match = re.search(r"'(\w+)'", error_str)
        if match:
            missing_name = match.group(1)
            
            # Provide helpful suggestions
            suggestions = {
                'pandas': "Use 'pd' instead of 'pandas'",
                'numpy': "Use 'np' instead of 'numpy'",
                'DataFrame': "Use 'pd.DataFrame' instead of 'DataFrame'",
            }
            
            if missing_name in suggestions:
                return f"{error_str}. {suggestions[missing_name]}"
            
            return f"{error_str}. Available: df, pd, np, DateCleaner, TextCleaner, CurrencyCleaner, and standard Python functions"
        
        return str(error)
    
    def execute_multiple(self, operations: List[Dict]) -> Dict[str, Any]:
        """Execute multiple operations in sequence"""
        logger.info(f"üîç execute_multiple called with {len(operations)} operations")
        results = []
        successful = 0
        failed = 0
        
        for idx, operation in enumerate(operations):
            python_code = operation.get("python_code")
            description = operation.get("description", f"Operation {idx+1}")
            logger.info(f"üîç Processing operation {idx+1}/{len(operations)}: {description}")
            if not python_code:
                logger.warning(f"‚ö†Ô∏è Operation {idx+1} has no python_code, skipping")
                continue
            
            try:
                result = self.execute(python_code, operation)
                results.append(result)
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"Operation failed: {operation.get('description', 'Unknown')} - {str(e)}")
                raise
        
        return {
            "total": len(operations),
            "successful": successful,
            "failed": failed,
            "results": results,
            "final_df": self.df,
            "log": self.execution_log
        }
    
    def get_dataframe(self) -> pd.DataFrame:
        """Get current dataframe"""
        return self.df.copy()
    
    def get_result(self) -> Any:
        """Get last result"""
        return self.result
    
    def get_execution_log(self) -> List[str]:
        """Get execution log"""
        return self.execution_log.copy()
    
    def get_errors(self) -> List[str]:
        """Get errors"""
        return self.errors.copy()

