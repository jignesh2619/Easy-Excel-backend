"""
Python Executor

Robust executor for executing Python code generated by GPT-4.
Handles all data operations: formulas, cleaning, filtering, sorting, etc.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
from datetime import datetime, date, timedelta
import logging
import re
from services.cleaning.dates import DateCleaner
from services.cleaning.currency import CurrencyCleaner
from services.cleaning.text import TextCleaner

logger = logging.getLogger(__name__)


class PythonExecutor:
    """Robust Python code executor for Excel operations"""
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize executor with dataframe
        
        Args:
            df: DataFrame to operate on
        """
        self.df = df.copy()  # Work on copy
        self.original_df = df.copy()
        self.result = None
        self.execution_log: List[str] = []
        self.errors: List[str] = []
    
    def execute(self, python_code: str, operation_meta: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Execute Python code safely
        
        Args:
            python_code: Python code string to execute
            operation_meta: Optional metadata about the operation
        
        Returns:
            Dict with execution results
        """
        operation_meta = operation_meta or {}
        description = operation_meta.get("description", "Operation")
        result_type = operation_meta.get("result_type", "dataframe")
        
        # Step 1: Validate code
        validation_result = self._validate_code(python_code)
        if not validation_result["valid"]:
            error_msg = f"Code validation failed: {validation_result['error']}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Code validation failed for: {description}\nOriginal code: {python_code[:500]}")
            raise RuntimeError(error_msg)
        
        # Use cleaned code if available, otherwise use original
        code_to_execute = validation_result.get("cleaned_code", python_code)
        
        # Step 2: Prepare execution environment
        exec_globals = self._build_execution_environment()
        
        # Step 3: Execute code
        try:
            # Execute the cleaned code
            exec(code_to_execute, exec_globals)
            
            # Debug: Log extracted names and contacts if they exist
            if 'names' in exec_globals:
                names_list = exec_globals.get('names', [])
                logger.info(f"ðŸ” Extracted names count: {len(names_list)}, sample: {names_list[:5] if len(names_list) > 0 else '[]'}")
            if 'contacts' in exec_globals:
                contacts_list = exec_globals.get('contacts', [])
                logger.info(f"ðŸ” Extracted contacts count: {len(contacts_list)}, sample: {contacts_list[:5] if len(contacts_list) > 0 else '[]'}")
            
            # Step 4: Extract results
            result = self._extract_results(exec_globals, result_type)
            
            # Step 5: Update dataframe
            if 'df' in exec_globals:
                self.df = exec_globals['df']
                # Ensure index is reset after operations
                if not self.df.index.equals(pd.RangeIndex(len(self.df))):
                    self.df = self.df.reset_index(drop=True)
                
                # Debug: Log DataFrame state after execution
                if 'Student Name' in self.df.columns:
                    filled_student = self.df['Student Name'].notna().sum()
                    logger.info(f"ðŸ” After execution - Student Name: {filled_student}/{len(self.df)} filled")
                if 'Contact No.' in self.df.columns:
                    filled_contact = self.df['Contact No.'].notna().sum()
                    logger.info(f"ðŸ” After execution - Contact No.: {filled_contact}/{len(self.df)} filled")
            
            # Step 6: Store result
            if result is not None:
                self.result = result
            
            # Step 7: Log success
            self.execution_log.append(f"âœ“ {description}")
            logger.info(f"Successfully executed: {description}")
            
            return {
                "success": True,
                "result": result,
                "description": description,
                "rows_affected": len(self.df),
                "columns": list(self.df.columns)
            }
            
        except NameError as e:
            error_msg = self._handle_name_error(e, python_code)
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except KeyError as e:
            error_str = str(e)
            # Check if this is a drop operation trying to drop non-existent columns
            # If so, handle gracefully (columns might have been dropped already or never created)
            if "drop" in python_code.lower() and ("not found in axis" in error_str or "not found" in error_str.lower()):
                # Extract column names from error if possible
                import re
                # Try to extract column names from error message
                col_match = re.search(r"\[(.*?)\]", error_str)
                if col_match:
                    missing_cols = col_match.group(1)
                    logger.warning(f"âš ï¸ Drop operation: Columns {missing_cols} not found, skipping drop (may have been dropped already or never created)")
                    self.execution_log.append(f"âš  {description}: Columns {missing_cols} not found, skipping (safe to ignore)")
                    # Return success since this is a cleanup operation
                    return {
                        "success": True,
                        "result": None,
                        "description": description,
                        "rows_affected": len(self.df),
                        "columns": list(self.df.columns),
                        "warning": f"Columns {missing_cols} not found, operation skipped"
                    }
            
            error_msg = f"Column not found: {str(e)}. Available columns: {list(self.df.columns)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except ValueError as e:
            error_str = str(e)
            # Check for the specific "Length of values does not match length of index" error
            if "Length of values" in error_str and "does not match length of index" in error_str:
                error_msg = f"Execution failed: {error_str}. This usually happens when trying to assign a list of values to a DataFrame row. When adding rows, create a dictionary with ONLY the columns you need, then use pd.concat([df, pd.DataFrame([new_row])], ignore_index=True). Example: new_row = {{'ColumnName': value}}; df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)"
            else:
                error_msg = f"Execution failed: {error_str}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except re.error as e:
            error_msg = f"Execution failed: Invalid regex pattern: {str(e)}. When removing or replacing special characters like *, ?, +, (, ), [, ], {{, }}, ^, $, |, \\, use regex=False. Example: df['Column'] = df['Column'].str.replace('*', '', regex=False)"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"Execution failed: {str(e)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
    
    def _build_execution_environment(self) -> Dict[str, Any]:
        """Build safe execution environment with all available resources"""
        return {
            # Data
            'df': self.df,
            'pd': pd,
            'np': np,
            'result': None,
            
            # Date/Time
            'datetime': datetime,
            'date': date,
            'timedelta': timedelta,
            
            # Cleaning utilities
            'DateCleaner': DateCleaner,
            'CurrencyCleaner': CurrencyCleaner,
            'TextCleaner': TextCleaner,
            
            # Math functions
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'sum': sum,
            'pow': pow,
            
            # Type conversion
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            
            # String functions
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'range': range,
            
            # Common operations
            'any': any,
            'all': all,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'reversed': reversed,
            
            # Pandas helpers
            'isna': pd.isna,
            'notna': pd.notna,
            'concat': pd.concat,
            'merge': pd.merge,
        }
    
    def _clean_code(self, python_code: str) -> str:
        """
        Clean code by removing markdown formatting and fixing common syntax errors
        
        Args:
            python_code: Raw code string that might contain markdown
            
        Returns:
            Cleaned code string
        """
        code = python_code.strip()
        
        # Remove markdown code blocks (```python ... ```)
        if code.startswith('```'):
            # Find the closing ```
            lines = code.split('\n')
            # Remove first line if it's ```python or ```
            if lines[0].startswith('```'):
                lines = lines[1:]
            # Remove last line if it's ```
            if lines and lines[-1].strip() == '```':
                lines = lines[:-1]
            code = '\n'.join(lines)
        
        # Remove any remaining ``` markers
        code = re.sub(r'```[a-z]*\n?', '', code)
        
        # Fix: Replace df.loc[i, ...] with df.iloc[i, ...] to avoid index issues
        # This is critical - loc uses the index label (which might not be 0,1,2,3...), 
        # while iloc uses position (which is always 0,1,2,3...)
        # Pattern: df.loc[i, 'Column'] or df.loc[i, "Column"] or df.loc[i, 'Column Name']
        # Match: df.loc[variable, any_string_in_quotes] - handle both single and double quotes
        # Use a more robust pattern that handles any content between brackets
        code = re.sub(r'df\.loc\[(\w+),\s*([\'"])([^\'"]+)\2', r'df.iloc[\1, \2\3\2', code)
        
        # Also handle cases without quotes (shouldn't happen but just in case)
        code = re.sub(r'df\.loc\[(\w+),\s*(\w+)', r'df.iloc[\1, \2', code)
        
        # CRITICAL FIX: The code might be all on one line with semicolons
        # We need to convert df.loc BEFORE we split by semicolons, otherwise the pattern won't match
        # But actually, the regex should work on the whole string. Let me try a different approach:
        # Replace ALL occurrences of df.loc[ with df.iloc[ regardless of what comes after
        # This is safer and will catch all cases
        code = code.replace('df.loc[', 'df.iloc[')
        
        # Fix: Convert semicolon-separated nested if statements to proper multi-line code
        # The LLM often generates: "for i in range(...): if condition: if condition: statement; statement"
        # This needs to be properly indented
        # First, let's handle the case where we have nested ifs in a for loop on one line
        if ';' in code and 'for ' in code and 'if ' in code:
            # Try to convert semicolon-separated code with nested ifs to proper format
            # Pattern: for i in range(...): if ...: if ...: statement; statement
            pattern = r'(for\s+\w+\s+in\s+range\([^)]+\)):\s+(if\s+[^:]+):\s+(if\s+[^:]+):\s+([^;]+(?:;[^;]+)*)'
            def fix_nested_ifs(match):
                loop = match.group(1)
                if1 = match.group(2)
                if2 = match.group(3)
                actions = match.group(4)
                # Split actions by semicolon
                action_list = [a.strip() for a in actions.split(';') if a.strip()]
                action_str = '\n            '.join(action_list)
                return f"{loop}:\n    {if1}:\n        {if2}:\n            {action_str}"
            code = re.sub(pattern, fix_nested_ifs, code)
            
            # Also handle single if in for loop
            pattern2 = r'(for\s+\w+\s+in\s+range\([^)]+\)):\s+(if\s+[^:]+):\s+([^;]+(?:;[^;]+)*)'
            def fix_single_if(match):
                loop = match.group(1)
                if_stmt = match.group(2)
                actions = match.group(3)
                action_list = [a.strip() for a in actions.split(';') if a.strip()]
                action_str = '\n        '.join(action_list)
                return f"{loop}:\n    {if_stmt}:\n        {action_str}"
            code = re.sub(pattern2, fix_single_if, code)
        
        # Fix common syntax errors
        # Fix: for_in -> for _ in (common LLM mistake)
        code = re.sub(r'\bfor_in\b', 'for _ in', code)
        # Fix: for _in -> for _ in (space before in but missing after _)
        code = re.sub(r'\bfor\s+_in\b', 'for _ in', code)
        # Fix: forin -> for _ in
        code = re.sub(r'\bforin\b', 'for _ in', code)
        # Fix: fori -> for i
        code = re.sub(r'\bfori\b', 'for i', code)
        # Fix: forj -> for j
        code = re.sub(r'\bforj\b', 'for j', code)
        # Fix: foridx -> for idx
        code = re.sub(r'\bforidx\b', 'for idx', code)
        
        # Fix: Incorrect blank row insertion pattern
        # Pattern: df = pd.concat([df, pd.DataFrame([{}] * len(df))], ignore_index=True)
        # This appends blank rows at the end instead of inserting them between rows
        # Replace with correct code that inserts blank rows between existing rows
        incorrect_pattern = r'df\s*=\s*pd\.concat\(\s*\[\s*df\s*,\s*pd\.DataFrame\(\s*\[\s*\{\}\s*\]\s*\*\s*len\(df\)\s*\)\s*\]\s*,\s*ignore_index\s*=\s*True\s*\)'
        if re.search(incorrect_pattern, code):
            # Replace with correct implementation
            code = re.sub(
                incorrect_pattern,
                '''new_rows = []
for i in range(len(df)):
    new_rows.append(df.iloc[i:i+1])
    new_rows.append(pd.DataFrame([{}], columns=df.columns))
df = pd.concat(new_rows, ignore_index=True)''',
                code
            )
            logger.info("ðŸ”§ Fixed incorrect blank row insertion pattern - now inserting between rows instead of appending")
        
        # Fix: Malformed generator/list comprehension at end of statement
        # Pattern: "statement) for i in range(...)" -> convert to proper loop
        # This fixes cases like: "df = pd.concat(...) for i in range(...)"
        # Match assignment followed by for loop at end
        def fix_malformed_loop(match):
            statement = match.group(1).strip()
            var = match.group(2)
            range_expr = match.group(3)
            # Convert to proper for loop with indentation
            return f'for {var} in {range_expr}:\n    {statement}'
        
        # Pattern 1: Simple assignment with method call
        # Matches: "df = pd.concat(...) for i in range(...)"
        # IMPORTANT: Match complete range() call including all arguments like range(len(df), 0, -1)
        pattern1 = r'(\w+\s*=\s*[^)]+\))\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        code = re.sub(pattern1, fix_malformed_loop, code)
        
        # Pattern 2: Assignment with method chain (e.g., .reset_index())
        # Matches: "df = pd.concat(...).reset_index(...) for i in range(...)"
        # IMPORTANT: Match complete range() call including all arguments
        pattern2 = r'(\w+\s*=\s*[^)]+\)(?:\.[^)]+\))+)\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        code = re.sub(pattern2, fix_malformed_loop, code)
        
        # Pattern 3: More complex - handles nested parentheses and method chains
        # Matches: "df = pd.concat([...]).reset_index(...) for i in range(...)"
        # This pattern handles the full line with nested brackets and method calls
        # IMPORTANT: Match complete range() call including all arguments like range(len(df), 0, -1)
        # Use a more robust pattern that handles nested parentheses in range()
        pattern3 = r'^(\w+\s*=\s*.+\)(?:\.\w+\([^)]*\))*)\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        def fix_complex_loop(match):
            statement = match.group(1).strip()
            var = match.group(2)
            range_expr = match.group(3)
            return f'for {var} in {range_expr}:\n    {statement}'
        
        # Fix: for loop inside function call parentheses (multi-line issue)
        # Pattern: .method(for var in range(...): ...) or method(for var in range(...)
        # This fixes cases like: reset_index(for i in range(len(df): drop=True))
        # We need to handle this across multiple lines
        def fix_for_in_function_call_multiline(code_str):
            # Join all lines to handle multi-line patterns
            full_code = ' '.join(code_str.split('\n'))
            
            # Pattern: .method_name(for var in range(...): params)
            # Or: method_name(for var in range(...): params)
            pattern = r'(\.?\w+)\(for\s+(\w+)\s+in\s+(range\([^)]+\)):\s*([^)]+)\)'
            
            def extract_and_fix(match):
                method_part = match.group(1)  # .reset_index or reset_index
                var = match.group(2)  # i
                range_expr = match.group(3)  # range(len(df)
                params = match.group(4).strip()  # drop=True
                
                # Reconstruct: remove the for loop from inside, we'll add it outside
                # Find the assignment statement before this method call
                # For now, return a marker we can process later
                return f"__FOR_LOOP_MARKER__{var}__{range_expr}__{method_part}({params})"
            
            # First pass: mark the problematic patterns
            marked_code = re.sub(pattern, extract_and_fix, full_code)
            
            # If we found any markers, reconstruct the code
            if '__FOR_LOOP_MARKER__' in marked_code:
                # Find the assignment before the marker
                # Pattern: df = pd.concat(...)__FOR_LOOP_MARKER__...
                marker_pattern = r'(\w+\s*=\s*[^_]+)__FOR_LOOP_MARKER__(\w+)__([^_]+)__(.+)'
                match = re.search(marker_pattern, marked_code)
                if match:
                    assignment = match.group(1).strip()
                    var = match.group(2)
                    range_expr = match.group(3)
                    method_call = match.group(4)
                    
                    # Reconstruct as proper for loop
                    return f'for {var} in {range_expr}:\n    {assignment}{method_call}'
            
            return code_str
        
        # Apply to each line separately to handle multi-line code
        lines = code.split('\n')
        fixed_lines = []
        for line in lines:
            line_stripped = line.strip()
            
            # First check for pattern3 (for loop at end of statement)
            # Use a more robust approach: find the "for var in range" and extract everything
            # This handles cases where range() has multiple arguments like range(len(df), 0, -1)
            # IMPORTANT: Skip list comprehensions - they have the pattern [... for ... in ...]
            # Check if this is a list comprehension by looking for opening bracket before "for"
            for_match = re.search(r'for\s+(\w+)\s+in\s+range\s*\(', line_stripped)
            is_list_comprehension = False
            if for_match:
                # Check if there's an opening bracket before "for" - this indicates a list comprehension
                before_for = line_stripped[:for_match.start()]
                # Count brackets to see if we're inside a list comprehension
                bracket_count = before_for.count('[') - before_for.count(']')
                if bracket_count > 0:
                    # We're inside a list comprehension - don't convert it
                    is_list_comprehension = True
            
            if for_match and not is_list_comprehension:
                # Found a for loop - extract the full range expression by finding the matching closing paren
                var = for_match.group(1)
                # Find the position of the opening '(' of range(
                range_open_paren_pos = for_match.end() - 1  # Position of '(' in "range("
                
                # Get the statement part (everything before "for")
                statement_end = for_match.start()
                statement = line_stripped[:statement_end].strip()
                
                # Find the complete range expression by counting parentheses
                # Start from "range(" - we need to include "range" in the expression
                range_start_pos = line_stripped.rfind('range', 0, range_open_paren_pos)
                range_expr = line_stripped[range_start_pos:range_open_paren_pos + 1]  # "range("
                paren_count = 1  # We already have the opening paren of range(
                found_range = True
                for i in range(range_open_paren_pos + 1, len(line_stripped)):  # Start after "range("
                    char = line_stripped[i]
                    range_expr += char
                    if char == '(':
                        paren_count += 1
                    elif char == ')':
                        paren_count -= 1
                        if paren_count == 0:
                            # Found the matching closing paren for range()
                            break
                
                # If we found a complete range expression and a statement, fix it
                if found_range and paren_count == 0 and statement:
                    # Check if there's leftover text after range_expr that should be part of range
                    range_expr_end_pos = range_start_pos + len(range_expr)
                    remaining_after_range = line_stripped[range_expr_end_pos:].strip()
                    
                    # If remaining text looks like range arguments (e.g., ", 0, -1)"), append it to range_expr
                    if remaining_after_range and re.match(r'^,\s*[^,)]+,\s*[^,)]+\)', remaining_after_range):
                        # Extract the range arguments
                        range_args_match = re.match(r'^,\s*([^,)]+),\s*([^,)]+)\)', remaining_after_range)
                        if range_args_match:
                            range_expr += remaining_after_range[:remaining_after_range.index(')') + 1]
                            remaining_after_range = remaining_after_range[remaining_after_range.index(')') + 1:].strip()
                    
                    # Clean up the statement - remove any trailing range arguments that got mixed in
                    statement_cleaned = statement
                    # Check if statement ends with something like ", 0, -1)" which suggests leftover range args
                    if re.search(r',\s*\d+,\s*-?\d+\)\s*$', statement_cleaned):
                        # Remove the trailing range arguments that got mixed into the statement
                        statement_cleaned = re.sub(r',\s*\d+,\s*-?\d+\)\s*$', '', statement_cleaned)
                    
                    fixed_lines.append(f'for {var} in {range_expr}:')
                    fixed_lines.append(f'    {statement_cleaned}')
                else:
                    # Try pattern3 as fallback
                    match_obj = re.match(pattern3, line_stripped)
                    if match_obj:
                        statement = match_obj.group(1).strip()
                        var = match_obj.group(2)
                        range_expr = match_obj.group(3)
                        fixed_lines.append(f'for {var} in {range_expr}:')
                        fixed_lines.append(f'    {statement}')
                    else:
                        fixed_lines.append(line)
            elif is_list_comprehension:
                # This is a list comprehension - leave it as-is (it's valid Python)
                fixed_lines.append(line)
            else:
                # Try pattern3 as fallback
                match_obj = re.match(pattern3, line_stripped)
                if match_obj:
                    statement = match_obj.group(1).strip()
                    var = match_obj.group(2)
                    range_expr = match_obj.group(3)
                    fixed_lines.append(f'for {var} in {range_expr}:')
                    fixed_lines.append(f'    {statement}')
                else:
                    # Check for for loop inside function call (handle multi-line)
                    # Join current line with previous lines to check for multi-line patterns
                    context_lines = fixed_lines[-3:] + [line] if len(fixed_lines) >= 3 else fixed_lines + [line]
                    context = '\n'.join(context_lines)
                    fixed_context = fix_for_in_function_call_multiline(context)
                    
                    if fixed_context != context:
                        # Pattern was fixed - replace the last few lines with the fixed version
                        # Remove the last few lines we checked
                        fixed_lines = fixed_lines[:-len(context_lines) + 1] if len(fixed_lines) >= len(context_lines) - 1 else []
                        # Add the fixed version (split back into lines)
                        fixed_lines.extend(fixed_context.split('\n'))
                    else:
                        fixed_lines.append(line)
        code = '\n'.join(fixed_lines)
        
        # Additional fix: Detect and fix "for" keyword appearing inside function call parentheses
        # This handles cases like: .reset_index(for i in range(...): ...)
        # We'll search for this pattern and restructure it
        def fix_for_inside_parentheses(code_str):
            # Pattern: find "for var in range" that appears after an opening parenthesis
            # This is a sign of malformed code
            lines = code_str.split('\n')
            result = []
            i = 0
            while i < len(lines):
                line = lines[i]
                # Check if this line or next lines contain "for" after an opening paren
                # Look ahead a few lines to catch multi-line issues
                lookahead = ' '.join(lines[i:min(i+5, len(lines))])
                
                # Pattern: .method(for var in range or method(for var in range
                if re.search(r'\(for\s+\w+\s+in\s+range', lookahead):
                    # Found malformed pattern - try to extract and fix
                    # Find the assignment statement before this
                    if i > 0:
                        # Look for assignment in previous lines
                        assignment_line = ''
                        for j in range(max(0, i-3), i):
                            if '=' in lines[j] and not lines[j].strip().startswith('#'):
                                assignment_line = lines[j]
                                break
                        
                        # Extract for loop details - match full range() call including all arguments
                        for_match = re.search(r'for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))', lookahead)
                        if for_match and assignment_line:
                            var = for_match.group(1)
                            range_expr = for_match.group(2)  # Already complete with all arguments
                            
                            # Remove the malformed for loop from the code
                            # Find where it starts and ends
                            cleaned_lines = []
                            skip_until_paren = False
                            for k in range(i, min(i+10, len(lines))):
                                if k < len(lines):
                                    cleaned = re.sub(r'\(for\s+\w+\s+in\s+range[^)]*\):\s*', '(', lines[k])
                                    cleaned = re.sub(r'for\s+\w+\s+in\s+range[^)]*\):\s*', '', cleaned)
                                    if cleaned.strip() and not cleaned.strip().startswith('for'):
                                        cleaned_lines.append(cleaned)
                            
                            # Reconstruct as proper for loop
                            if cleaned_lines:
                                result.append(f'for {var} in {range_expr}:')
                                result.append(f'    {assignment_line}')
                                for cl in cleaned_lines:
                                    result.append(f'    {cl}')
                                i += len(cleaned_lines)
                                continue
                
                result.append(line)
                i += 1
            
            return '\n'.join(result)
        
        # Apply the fix
        code = fix_for_inside_parentheses(code)
        
        # Clean up whitespace
        code = code.strip()
        
        return code
    
    def _validate_code(self, python_code: str) -> Dict[str, Any]:
        """
        Validate code before execution
        
        Returns:
            {"valid": bool, "error": str}
        """
        # Clean the code first (remove markdown, etc.)
        cleaned_code = self._clean_code(python_code)
        
        # Check if code is empty after cleaning
        if not cleaned_code or not cleaned_code.strip():
            return {"valid": False, "error": "Code is empty after cleaning"}
        
        # Check 1: No import statements
        if re.search(r'\bimport\s+\w+|from\s+\w+\s+import', cleaned_code):
            return {"valid": False, "error": "Import statements are not allowed"}
        
        # Check 2: No file operations
        dangerous_patterns = [
            r'\bopen\s*\(', r'\bread\s*\(', r'\bwrite\s*\(',
            r'__file__', r'__import__', r'eval\s*\(', r'exec\s*\(',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, cleaned_code):
                return {"valid": False, "error": f"Dangerous operation detected: {pattern}"}
        
        # Check 3: No system operations
        if re.search(r'\bos\.|sys\.|subprocess\.|shutil\.', cleaned_code):
            return {"valid": False, "error": "System operations are not allowed"}
        
        # Check 4: Basic syntax validation
        try:
            compile(cleaned_code, '<string>', 'exec')
        except SyntaxError as e:
            # Include the problematic code in error message
            error_line = getattr(e, 'lineno', 'unknown')
            error_text = getattr(e, 'text', '')
            code_preview = cleaned_code[:300] if len(cleaned_code) > 300 else cleaned_code
            return {
                "valid": False, 
                "error": f"Syntax error at line {error_line}: {str(e)}\nCode preview:\n{code_preview}"
            }
        
        # Debug: Log if df.loc was replaced with df.iloc
        if 'df.loc[' in python_code and 'df.iloc[' in cleaned_code:
            logger.info(f"ðŸ”§ Converted df.loc to df.iloc in code cleaning")
        elif 'df.loc[' in python_code:
            logger.warning(f"âš ï¸ df.loc found in code but not converted to df.iloc")
            logger.warning(f"âš ï¸ Original code snippet: {python_code[:500]}")
            logger.warning(f"âš ï¸ Cleaned code snippet (first 500 chars): {cleaned_code[:500]}")
            logger.warning(f"âš ï¸ Cleaned code snippet (full length: {len(cleaned_code)}): {cleaned_code}")
            # Force replacement if it wasn't done
            if 'df.loc[' in cleaned_code:
                cleaned_code = cleaned_code.replace('df.loc[', 'df.iloc[')
                logger.info(f"ðŸ”§ Force-converted remaining df.loc to df.iloc")
                logger.info(f"ðŸ”§ After force conversion (first 500 chars): {cleaned_code[:500]}")
        
        return {"valid": True, "error": None, "cleaned_code": cleaned_code}
    
    def _extract_results(self, exec_globals: Dict, result_type: str) -> Any:
        """Extract results from execution environment"""
        if result_type == "single_value":
            # Single value result (SUM, AVERAGE, etc.)
            if 'result' in exec_globals and exec_globals['result'] is not None:
                return exec_globals['result']
            return None
        
        elif result_type == "dataframe":
            # DataFrame operation (filter, sort, etc.)
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        elif result_type == "new_column":
            # New column created
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        return None
    
    def _handle_name_error(self, error: NameError, python_code: str) -> str:
        """Handle NameError with helpful messages"""
        error_str = str(error)
        
        # Extract the missing name
        match = re.search(r"'(\w+)'", error_str)
        if match:
            missing_name = match.group(1)
            
            # Provide helpful suggestions
            suggestions = {
                'pandas': "Use 'pd' instead of 'pandas'",
                'numpy': "Use 'np' instead of 'numpy'",
                'DataFrame': "Use 'pd.DataFrame' instead of 'DataFrame'",
            }
            
            if missing_name in suggestions:
                return f"{error_str}. {suggestions[missing_name]}"
            
            return f"{error_str}. Available: df, pd, np, DateCleaner, TextCleaner, CurrencyCleaner, and standard Python functions"
        
        return str(error)
    
    def execute_multiple(self, operations: List[Dict]) -> Dict[str, Any]:
        """
        Execute multiple operations in sequence
        
        Args:
            operations: List of operation dicts with 'python_code' and 'description'
        
        Returns:
            Dict with execution summary
        """
        logger.info(f"ðŸ” execute_multiple called with {len(operations)} operations")
        results = []
        successful = 0
        failed = 0
        
        for idx, operation in enumerate(operations):
            python_code = operation.get("python_code")
            description = operation.get("description", f"Operation {idx+1}")
            logger.info(f"ðŸ” Processing operation {idx+1}/{len(operations)}: {description}")
            if not python_code:
                logger.warning(f"âš ï¸ Operation {idx+1} has no python_code, skipping")
                continue
            
            try:
                result = self.execute(python_code, operation)
                results.append(result)
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"Operation failed: {operation.get('description', 'Unknown')} - {str(e)}")
                # Raise to stop execution on first error
                raise
        
        return {
            "total": len(operations),
            "successful": successful,
            "failed": failed,
            "results": results,
            "final_df": self.df,
            "log": self.execution_log
        }
    
    def get_dataframe(self) -> pd.DataFrame:
        """Get current dataframe"""
        return self.df.copy()
    
    def get_result(self) -> Any:
        """Get last result"""
        return self.result
    
    def get_execution_log(self) -> List[str]:
        """Get execution log"""
        return self.execution_log.copy()
    
    def get_errors(self) -> List[str]:
        """Get errors"""
        return self.errors.copy()

