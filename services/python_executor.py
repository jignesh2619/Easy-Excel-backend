"""
Python Executor

Robust executor for executing Python code generated by GPT-4.
Handles all data operations: formulas, cleaning, filtering, sorting, etc.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
from datetime import datetime, date, timedelta
import logging
import re
from services.cleaning.dates import DateCleaner
from services.cleaning.currency import CurrencyCleaner
from services.cleaning.text import TextCleaner

logger = logging.getLogger(__name__)


class PythonExecutor:
    """Robust Python code executor for Excel operations"""
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize executor with dataframe
        
        Args:
            df: DataFrame to operate on
        """
        self.df = df.copy()  # Work on copy
        self.original_df = df.copy()
        self.result = None
        self.execution_log: List[str] = []
        self.errors: List[str] = []
    
    def execute(self, python_code: str, operation_meta: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Execute Python code safely
        
        Args:
            python_code: Python code string to execute
            operation_meta: Optional metadata about the operation
        
        Returns:
            Dict with execution results
        """
        operation_meta = operation_meta or {}
        description = operation_meta.get("description", "Operation")
        result_type = operation_meta.get("result_type", "dataframe")
        
        # Step 1: Validate code
        validation_result = self._validate_code(python_code)
        if not validation_result["valid"]:
            error_msg = f"Code validation failed: {validation_result['error']}"
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            raise RuntimeError(error_msg)
        
        # Step 2: Prepare execution environment
        exec_globals = self._build_execution_environment()
        
        # Step 3: Execute code
        try:
            # Execute the code
            exec(python_code, exec_globals)
            
            # Step 4: Extract results
            result = self._extract_results(exec_globals, result_type)
            
            # Step 5: Update dataframe
            if 'df' in exec_globals:
                self.df = exec_globals['df']
                # Ensure index is reset after operations
                if not self.df.index.equals(pd.RangeIndex(len(self.df))):
                    self.df = self.df.reset_index(drop=True)
            
            # Step 6: Store result
            if result is not None:
                self.result = result
            
            # Step 7: Log success
            self.execution_log.append(f"✓ {description}")
            logger.info(f"Successfully executed: {description}")
            
            return {
                "success": True,
                "result": result,
                "description": description,
                "rows_affected": len(self.df),
                "columns": list(self.df.columns)
            }
            
        except NameError as e:
            error_msg = self._handle_name_error(e, python_code)
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except KeyError as e:
            error_msg = f"Column not found: {str(e)}. Available columns: {list(self.df.columns)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except ValueError as e:
            error_str = str(e)
            # Check for the specific "Length of values does not match length of index" error
            if "Length of values" in error_str and "does not match length of index" in error_str:
                error_msg = f"Execution failed: {error_str}. This usually happens when trying to assign a list of values to a DataFrame row. When adding rows, create a dictionary with ONLY the columns you need, then use pd.concat([df, pd.DataFrame([new_row])], ignore_index=True). Example: new_row = {{'ColumnName': value}}; df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)"
            else:
                error_msg = f"Execution failed: {error_str}"
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except re.error as e:
            error_msg = f"Execution failed: Invalid regex pattern: {str(e)}. When removing or replacing special characters like *, ?, +, (, ), [, ], {{, }}, ^, $, |, \\, use regex=False. Example: df['Column'] = df['Column'].str.replace('*', '', regex=False)"
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"Execution failed: {str(e)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"✗ {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
    
    def _build_execution_environment(self) -> Dict[str, Any]:
        """Build safe execution environment with all available resources"""
        return {
            # Data
            'df': self.df,
            'pd': pd,
            'np': np,
            'result': None,
            
            # Date/Time
            'datetime': datetime,
            'date': date,
            'timedelta': timedelta,
            
            # Cleaning utilities
            'DateCleaner': DateCleaner,
            'CurrencyCleaner': CurrencyCleaner,
            'TextCleaner': TextCleaner,
            
            # Math functions
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'sum': sum,
            'pow': pow,
            
            # Type conversion
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            
            # String functions
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'range': range,
            
            # Common operations
            'any': any,
            'all': all,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'reversed': reversed,
            
            # Pandas helpers
            'isna': pd.isna,
            'notna': pd.notna,
            'concat': pd.concat,
            'merge': pd.merge,
        }
    
    def _validate_code(self, python_code: str) -> Dict[str, Any]:
        """
        Validate code before execution
        
        Returns:
            {"valid": bool, "error": str}
        """
        # Check 1: No import statements
        if re.search(r'\bimport\s+\w+|from\s+\w+\s+import', python_code):
            return {"valid": False, "error": "Import statements are not allowed"}
        
        # Check 2: No file operations
        dangerous_patterns = [
            r'\bopen\s*\(', r'\bread\s*\(', r'\bwrite\s*\(',
            r'__file__', r'__import__', r'eval\s*\(', r'exec\s*\(',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, python_code):
                return {"valid": False, "error": f"Dangerous operation detected: {pattern}"}
        
        # Check 3: No system operations
        if re.search(r'\bos\.|sys\.|subprocess\.|shutil\.', python_code):
            return {"valid": False, "error": "System operations are not allowed"}
        
        # Check 4: Basic syntax validation
        try:
            compile(python_code, '<string>', 'exec')
        except SyntaxError as e:
            return {"valid": False, "error": f"Syntax error: {str(e)}"}
        
        return {"valid": True, "error": None}
    
    def _extract_results(self, exec_globals: Dict, result_type: str) -> Any:
        """Extract results from execution environment"""
        if result_type == "single_value":
            # Single value result (SUM, AVERAGE, etc.)
            if 'result' in exec_globals and exec_globals['result'] is not None:
                return exec_globals['result']
            return None
        
        elif result_type == "dataframe":
            # DataFrame operation (filter, sort, etc.)
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        elif result_type == "new_column":
            # New column created
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        return None
    
    def _handle_name_error(self, error: NameError, python_code: str) -> str:
        """Handle NameError with helpful messages"""
        error_str = str(error)
        
        # Extract the missing name
        match = re.search(r"'(\w+)'", error_str)
        if match:
            missing_name = match.group(1)
            
            # Provide helpful suggestions
            suggestions = {
                'pandas': "Use 'pd' instead of 'pandas'",
                'numpy': "Use 'np' instead of 'numpy'",
                'DataFrame': "Use 'pd.DataFrame' instead of 'DataFrame'",
            }
            
            if missing_name in suggestions:
                return f"{error_str}. {suggestions[missing_name]}"
            
            return f"{error_str}. Available: df, pd, np, DateCleaner, TextCleaner, CurrencyCleaner, and standard Python functions"
        
        return str(error)
    
    def execute_multiple(self, operations: List[Dict]) -> Dict[str, Any]:
        """
        Execute multiple operations in sequence
        
        Args:
            operations: List of operation dicts with 'python_code' and 'description'
        
        Returns:
            Dict with execution summary
        """
        results = []
        successful = 0
        failed = 0
        
        for operation in operations:
            python_code = operation.get("python_code")
            if not python_code:
                continue
            
            try:
                result = self.execute(python_code, operation)
                results.append(result)
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"Operation failed: {operation.get('description', 'Unknown')} - {str(e)}")
                # Raise to stop execution on first error
                raise
        
        return {
            "total": len(operations),
            "successful": successful,
            "failed": failed,
            "results": results,
            "final_df": self.df,
            "log": self.execution_log
        }
    
    def get_dataframe(self) -> pd.DataFrame:
        """Get current dataframe"""
        return self.df.copy()
    
    def get_result(self) -> Any:
        """Get last result"""
        return self.result
    
    def get_execution_log(self) -> List[str]:
        """Get execution log"""
        return self.execution_log.copy()
    
    def get_errors(self) -> List[str]:
        """Get errors"""
        return self.errors.copy()

