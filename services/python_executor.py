"""
Python Executor

Robust executor for executing Python code generated by GPT-4.
Handles all data operations: formulas, cleaning, filtering, sorting, etc.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
from datetime import datetime, date, timedelta
import logging
import re
from services.cleaning.dates import DateCleaner
from services.cleaning.currency import CurrencyCleaner
from services.cleaning.text import TextCleaner

logger = logging.getLogger(__name__)


class PythonExecutor:
    """Robust Python code executor for Excel operations"""
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize executor with dataframe
        
        Args:
            df: DataFrame to operate on
        """
        self.df = df.copy()  # Work on copy
        self.original_df = df.copy()
        self.result = None
        self.execution_log: List[str] = []
        self.errors: List[str] = []
    
    def execute(self, python_code: str, operation_meta: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Execute Python code safely
        
        Args:
            python_code: Python code string to execute
            operation_meta: Optional metadata about the operation
        
        Returns:
            Dict with execution results
        """
        operation_meta = operation_meta or {}
        description = operation_meta.get("description", "Operation")
        result_type = operation_meta.get("result_type", "dataframe")
        
        # Step 1: Validate code
        validation_result = self._validate_code(python_code)
        if not validation_result["valid"]:
            error_msg = f"Code validation failed: {validation_result['error']}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Code validation failed for: {description}\nOriginal code: {python_code[:500]}")
            raise RuntimeError(error_msg)
        
        # Use cleaned code if available, otherwise use original
        code_to_execute = validation_result.get("cleaned_code", python_code)
        
        # Step 2: Prepare execution environment
        exec_globals = self._build_execution_environment()
        
        # Step 3: Execute code
        try:
            # Execute the cleaned code
            exec(code_to_execute, exec_globals)
            
            # Debug: Log extracted names and contacts if they exist
            if 'names' in exec_globals:
                names_list = exec_globals.get('names', [])
                logger.info(f"üîç Extracted names count: {len(names_list)}, sample: {names_list[:5] if len(names_list) > 0 else '[]'}")
            if 'contacts' in exec_globals:
                contacts_list = exec_globals.get('contacts', [])
                logger.info(f"üîç Extracted contacts count: {len(contacts_list)}, sample: {contacts_list[:5] if len(contacts_list) > 0 else '[]'}")
            
            # Step 4: Extract results
            result = self._extract_results(exec_globals, result_type)
            
            # Step 5: Update dataframe
            if 'df' in exec_globals:
                self.df = exec_globals['df']
                # Ensure index is reset after operations
                if not self.df.index.equals(pd.RangeIndex(len(self.df))):
                    self.df = self.df.reset_index(drop=True)
                
                # Debug: Log DataFrame state after execution
                if 'Student Name' in self.df.columns:
                    filled_student = self.df['Student Name'].notna().sum()
                    logger.info(f"üîç After execution - Student Name: {filled_student}/{len(self.df)} filled")
                if 'Contact No.' in self.df.columns:
                    filled_contact = self.df['Contact No.'].notna().sum()
                    logger.info(f"üîç After execution - Contact No.: {filled_contact}/{len(self.df)} filled")
            
            # Step 6: Store result
            if result is not None:
                self.result = result
            
            # Step 7: Log success
            self.execution_log.append(f"‚úì {description}")
            logger.info(f"Successfully executed: {description}")
            
            return {
                "success": True,
                "result": result,
                "description": description,
                "rows_affected": len(self.df),
                "columns": list(self.df.columns)
            }
            
        except NameError as e:
            error_msg = self._handle_name_error(e, python_code)
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except KeyError as e:
            error_str = str(e)
            # Check if this is a drop operation trying to drop non-existent columns
            # If so, handle gracefully (columns might have been dropped already or never created)
            if "drop" in python_code.lower() and ("not found in axis" in error_str or "not found" in error_str.lower()):
                # Extract column names from error if possible
                import re
                # Try to extract column names from error message
                col_match = re.search(r"\[(.*?)\]", error_str)
                if col_match:
                    missing_cols = col_match.group(1)
                    logger.warning(f"‚ö†Ô∏è Drop operation: Columns {missing_cols} not found, skipping drop (may have been dropped already or never created)")
                    self.execution_log.append(f"‚ö† {description}: Columns {missing_cols} not found, skipping (safe to ignore)")
                    # Return success since this is a cleanup operation
                    return {
                        "success": True,
                        "result": None,
                        "description": description,
                        "rows_affected": len(self.df),
                        "columns": list(self.df.columns),
                        "warning": f"Columns {missing_cols} not found, operation skipped"
                    }
            
            error_msg = f"Column not found: {str(e)}. Available columns: {list(self.df.columns)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except ValueError as e:
            error_str = str(e)
            # Check for the specific "Length of values does not match length of index" error
            if "Length of values" in error_str and "does not match length of index" in error_str:
                error_msg = f"Execution failed: {error_str}. This usually happens when trying to assign a list of values to a DataFrame row. When adding rows, create a dictionary with ONLY the columns you need, then use pd.concat([df, pd.DataFrame([new_row])], ignore_index=True). Example: new_row = {{'ColumnName': value}}; df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)"
            else:
                error_msg = f"Execution failed: {error_str}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except re.error as e:
            error_msg = f"Execution failed: Invalid regex pattern: {str(e)}. When removing or replacing special characters like *, ?, +, (, ), [, ], {{, }}, ^, $, |, \\, use regex=False. Example: df['Column'] = df['Column'].str.replace('*', '', regex=False)"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"Execution failed: {str(e)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"‚úó {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
    
    def _build_execution_environment(self) -> Dict[str, Any]:
        """Build safe execution environment with all available resources"""
        return {
            # Data
            'df': self.df,
            'pd': pd,
            'np': np,
            'result': None,
            
            # Date/Time
            'datetime': datetime,
            'date': date,
            'timedelta': timedelta,
            
            # Cleaning utilities
            'DateCleaner': DateCleaner,
            'CurrencyCleaner': CurrencyCleaner,
            'TextCleaner': TextCleaner,
            
            # Math functions
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'sum': sum,
            'pow': pow,
            
            # Type conversion
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            
            # String functions
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'range': range,
            
            # Common operations
            'any': any,
            'all': all,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'reversed': reversed,
            
            # Pandas helpers
            'isna': pd.isna,
            'notna': pd.notna,
            'concat': pd.concat,
            'merge': pd.merge,
        }
    
    def _clean_code(self, python_code: str) -> str:
        """
        Clean code by removing markdown formatting and fixing common syntax errors
        
        Args:
            python_code: Raw code string that might contain markdown
            
        Returns:
            Cleaned code string
        """
        code = python_code.strip()
        
        # Remove markdown code blocks (```python ... ```)
        if code.startswith('```'):
            # Find the closing ```
            lines = code.split('\n')
            # Remove first line if it's ```python or ```
            if lines[0].startswith('```'):
                lines = lines[1:]
            # Remove last line if it's ```
            if lines and lines[-1].strip() == '```':
                lines = lines[:-1]
            code = '\n'.join(lines)
        
        # Remove any remaining ``` markers
        code = re.sub(r'```[a-z]*\n?', '', code)
        
        # Fix: Replace df.loc[i, 'Column Name'] with df.iloc[i, df.columns.get_loc('Column Name')]
        # This is critical - loc uses the index label (which might not be 0,1,2,3...), 
        # while iloc uses position (which is always 0,1,2,3...)
        # BUT: iloc doesn't accept column names, only integer positions!
        # So we need to convert df.loc[i, 'Column Name'] to df.iloc[i, df.columns.get_loc('Column Name')]
        
        # Pattern 1: df.loc[i, 'Column Name'] or df.loc[i, "Column Name"]
        # Match: df.loc[variable, any_string_in_quotes] - handle both single and double quotes
        def replace_loc_with_iloc(match):
            row_var = match.group(1)  # e.g., "i"
            quote_char = match.group(2)  # ' or "
            col_name = match.group(3)  # e.g., "Student Name"
            return f'df.iloc[{row_var}, df.columns.get_loc({quote_char}{col_name}{quote_char})]'
        
        code = re.sub(r'df\.loc\[(\w+),\s*([\'"])([^\'"]+)\2\]', replace_loc_with_iloc, code)
        
        # Pattern 2: Also fix df.iloc[i, 'Column Name'] that was incorrectly converted earlier
        # This handles cases where df.loc was already converted to df.iloc but with column names
        def replace_iloc_with_get_loc(match):
            row_var = match.group(1)  # e.g., "i"
            quote_char = match.group(2)  # ' or "
            col_name = match.group(3)  # e.g., "Student Name"
            return f'df.iloc[{row_var}, df.columns.get_loc({quote_char}{col_name}{quote_char})]'
        
        code = re.sub(r'df\.iloc\[(\w+),\s*([\'"])([^\'"]+)\2\]', replace_iloc_with_get_loc, code)
        
        # Pattern 3: df.loc[i, ColumnName] (without quotes - shouldn't happen but handle it)
        # For this case, we'll just keep it as df.loc since we can't determine the column name
        # Actually, let's skip this pattern since column names should always be in quotes
        
        # Pattern 4: df.loc[i, ...] where the second argument is not a string (e.g., integer)
        # In this case, we can safely convert to df.iloc[i, ...]
        # But this is rare - usually column names are used
        
        # IMPORTANT: Don't restructure semicolon-separated code if it's valid Python
        # The code might be all on one line with semicolons, which is valid Python syntax
        # Only restructure if it's actually malformed (e.g., "statement) for i in range(...)" at end)
        # For now, we'll skip the automatic restructuring of semicolon-separated code
        # and just ensure df.loc is replaced with df.iloc (already done above)
        
        # Fix common syntax errors
        # Fix: for_in -> for _ in (common LLM mistake)
        code = re.sub(r'\bfor_in\b', 'for _ in', code)
        # Fix: for _in -> for _ in (space before in but missing after _)
        code = re.sub(r'\bfor\s+_in\b', 'for _ in', code)
        # Fix: forin -> for _ in
        code = re.sub(r'\bforin\b', 'for _ in', code)
        # Fix: fori -> for i
        code = re.sub(r'\bfori\b', 'for i', code)
        # Fix: forj -> for j
        code = re.sub(r'\bforj\b', 'for j', code)
        # Fix: foridx -> for idx
        code = re.sub(r'\bforidx\b', 'for idx', code)
        
        # Fix: Convert semicolon-separated nested if statements to properly indented code
        # Pattern: "for i in range(...): if condition: if condition2: statement"
        # This is invalid Python - nested if statements need proper indentation
        # We'll convert it to multi-line code with proper indentation
        if ';' in code and re.search(r'for\s+\w+\s+in\s+range[^:]+:\s*if\s+.*:\s*if\s+', code):
            # Split by semicolons but preserve structure
            lines = []
            current_line = ''
            paren_count = 0
            bracket_count = 0
            in_string = False
            string_char = None
            
            i = 0
            while i < len(code):
                char = code[i]
                
                # Track string boundaries
                if char in ('"', "'") and (i == 0 or code[i-1] != '\\'):
                    if not in_string:
                        in_string = True
                        string_char = char
                    elif char == string_char:
                        in_string = False
                        string_char = None
                
                if not in_string:
                    if char == '(':
                        paren_count += 1
                    elif char == ')':
                        paren_count -= 1
                    elif char == '[':
                        bracket_count += 1
                    elif char == ']':
                        bracket_count -= 1
                    elif char == ';' and paren_count == 0 and bracket_count == 0:
                        # Safe to split here
                        if current_line.strip():
                            lines.append(current_line.strip())
                        current_line = ''
                        i += 1
                        continue
                
                current_line += char
                i += 1
            
            if current_line.strip():
                lines.append(current_line.strip())
            
            # Now convert lines with nested if statements to properly indented code
            fixed_lines = []
            for line in lines:
                # Check if this line has nested if statements
                if re.search(r'for\s+\w+\s+in\s+range[^:]+:\s*if\s+.*:\s*if\s+', line):
                    # Convert to multi-line with proper indentation
                    # Pattern: "for i in range(...): if condition: if condition2: statement"
                    match = re.match(r'(for\s+\w+\s+in\s+range[^:]+):\s*(if\s+[^:]+):\s*(if\s+[^:]+):\s*(.+)', line)
                    if match:
                        for_loop = match.group(1)
                        if1 = match.group(2)
                        if2 = match.group(3)
                        statement = match.group(4)
                        fixed_lines.append(f'{for_loop}:')
                        fixed_lines.append(f'    {if1}:')
                        fixed_lines.append(f'        {if2}:')
                        fixed_lines.append(f'            {statement}')
                    else:
                        # Try simpler pattern: "for i in range(...): if condition: statement"
                        match = re.match(r'(for\s+\w+\s+in\s+range[^:]+):\s*(if\s+[^:]+):\s*(.+)', line)
                        if match:
                            for_loop = match.group(1)
                            if1 = match.group(2)
                            statement = match.group(3)
                            fixed_lines.append(f'{for_loop}:')
                            fixed_lines.append(f'    {if1}:')
                            fixed_lines.append(f'        {statement}')
                        else:
                            fixed_lines.append(line)
                else:
                    fixed_lines.append(line)
            
            code = '\n'.join(fixed_lines)
        
        # Fix: Incorrect blank row insertion pattern
        # Pattern: df = pd.concat([df, pd.DataFrame([{}] * len(df))], ignore_index=True)
        # This appends blank rows at the end instead of inserting them between rows
        # Replace with correct code that inserts blank rows between existing rows
        incorrect_pattern = r'df\s*=\s*pd\.concat\(\s*\[\s*df\s*,\s*pd\.DataFrame\(\s*\[\s*\{\}\s*\]\s*\*\s*len\(df\)\s*\)\s*\]\s*,\s*ignore_index\s*=\s*True\s*\)'
        if re.search(incorrect_pattern, code):
            # Replace with correct implementation
            code = re.sub(
                incorrect_pattern,
                '''new_rows = []
for i in range(len(df)):
    new_rows.append(df.iloc[i:i+1])
    new_rows.append(pd.DataFrame([{}], columns=df.columns))
df = pd.concat(new_rows, ignore_index=True)''',
                code
            )
            logger.info("üîß Fixed incorrect blank row insertion pattern - now inserting between rows instead of appending")
        
        # Fix: Malformed generator/list comprehension at end of statement
        # Pattern: "statement) for i in range(...)" -> convert to proper loop
        # This fixes cases like: "df = pd.concat(...) for i in range(...)"
        # BUT: Only apply if the pattern is actually malformed (statement ends with ) and for comes after)
        # Don't match if there are semicolons between - that's valid Python
        def fix_malformed_loop(match):
            statement = match.group(1).strip()
            var = match.group(2)
            range_expr = match.group(3)
            # Convert to proper for loop with indentation
            return f'for {var} in {range_expr}:\n    {statement}'
        
        # IMPORTANT: Only match patterns where "for" comes immediately after a closing paren
        # This indicates a malformed pattern like "df = pd.concat(...) for i in range(...)"
        # Don't match if there are semicolons or other code between - that's valid Python
        
        # Pattern 1: Simple assignment with method call - only if "for" comes right after )
        # Matches: "df = pd.concat(...) for i in range(...)" (no semicolon between)
        pattern1 = r'(\w+\s*=\s*[^)]+\))\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        # Only apply if there's no semicolon between the statement and "for"
        if ';' not in code or not re.search(r'\)\s*;\s*for\s+', code):
            code = re.sub(pattern1, fix_malformed_loop, code)
        
        # Pattern 2: Assignment with method chain - only if "for" comes right after )
        pattern2 = r'(\w+\s*=\s*[^)]+\)(?:\.[^)]+\))+)\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        if ';' not in code or not re.search(r'\)\s*;\s*for\s+', code):
            code = re.sub(pattern2, fix_malformed_loop, code)
        
        # Pattern 3: More complex - only if "for" comes right after )
        pattern3 = r'^(\w+\s*=\s*.+\)(?:\.\w+\([^)]*\))*)\s+for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))'
        def fix_complex_loop(match):
            statement = match.group(1).strip()
            var = match.group(2)
            range_expr = match.group(3)
            return f'for {var} in {range_expr}:\n    {statement}'
        # Only apply if there's no semicolon between
        if ';' not in code or not re.search(r'\)\s*;\s*for\s+', code):
            code = re.sub(pattern3, fix_complex_loop, code)
        
        # Fix: for loop inside function call parentheses (multi-line issue)
        # Pattern: .method(for var in range(...): ...) or method(for var in range(...)
        # This fixes cases like: reset_index(for i in range(len(df): drop=True))
        # We need to handle this across multiple lines
        def fix_for_in_function_call_multiline(code_str):
            # Join all lines to handle multi-line patterns
            full_code = ' '.join(code_str.split('\n'))
            
            # Pattern: .method_name(for var in range(...): params)
            # Or: method_name(for var in range(...): params)
            pattern = r'(\.?\w+)\(for\s+(\w+)\s+in\s+(range\([^)]+\)):\s*([^)]+)\)'
            
            def extract_and_fix(match):
                method_part = match.group(1)  # .reset_index or reset_index
                var = match.group(2)  # i
                range_expr = match.group(3)  # range(len(df)
                params = match.group(4).strip()  # drop=True
                
                # Reconstruct: remove the for loop from inside, we'll add it outside
                # Find the assignment statement before this method call
                # For now, return a marker we can process later
                return f"__FOR_LOOP_MARKER__{var}__{range_expr}__{method_part}({params})"
            
            # First pass: mark the problematic patterns
            marked_code = re.sub(pattern, extract_and_fix, full_code)
            
            # If we found any markers, reconstruct the code
            if '__FOR_LOOP_MARKER__' in marked_code:
                # Find the assignment before the marker
                # Pattern: df = pd.concat(...)__FOR_LOOP_MARKER__...
                marker_pattern = r'(\w+\s*=\s*[^_]+)__FOR_LOOP_MARKER__(\w+)__([^_]+)__(.+)'
                match = re.search(marker_pattern, marked_code)
                if match:
                    assignment = match.group(1).strip()
                    var = match.group(2)
                    range_expr = match.group(3)
                    method_call = match.group(4)
                    
                    # Reconstruct as proper for loop
                    return f'for {var} in {range_expr}:\n    {assignment}{method_call}'
            
            return code_str
        
        # Apply to each line separately to handle multi-line code
        lines = code.split('\n')
        fixed_lines = []
        for line in lines:
            line_stripped = line.strip()
            
            # IMPORTANT: If the line contains semicolons, it's likely valid Python code
            # Don't try to restructure it - just leave it as-is after df.loc replacement
            if ';' in line_stripped:
                # This is semicolon-separated code - likely valid Python
                # Just add it as-is (df.loc should already be replaced above)
                fixed_lines.append(line)
                continue
            
            # First check for pattern3 (for loop at end of statement)
            # Use a more robust approach: find the "for var in range" and extract everything
            # This handles cases where range() has multiple arguments like range(len(df), 0, -1)
            # IMPORTANT: Skip list comprehensions - they have the pattern [... for ... in ...]
            # Check if this is a list comprehension by looking for opening bracket before "for"
            for_match = re.search(r'for\s+(\w+)\s+in\s+range\s*\(', line_stripped)
            is_list_comprehension = False
            if for_match:
                # Check if there's an opening bracket before "for" - this indicates a list comprehension
                before_for = line_stripped[:for_match.start()]
                # Count brackets to see if we're inside a list comprehension
                bracket_count = before_for.count('[') - before_for.count(']')
                if bracket_count > 0:
                    # We're inside a list comprehension - don't convert it
                    is_list_comprehension = True
            
            if for_match and not is_list_comprehension:
                # Found a for loop - extract the full range expression by finding the matching closing paren
                var = for_match.group(1)
                # Find the position of the opening '(' of range(
                range_open_paren_pos = for_match.end() - 1  # Position of '(' in "range("
                
                # Get the statement part (everything before "for")
                statement_end = for_match.start()
                statement = line_stripped[:statement_end].strip()
                
                # Find the complete range expression by counting parentheses
                # Start from "range(" - we need to include "range" in the expression
                range_start_pos = line_stripped.rfind('range', 0, range_open_paren_pos)
                range_expr = line_stripped[range_start_pos:range_open_paren_pos + 1]  # "range("
                paren_count = 1  # We already have the opening paren of range(
                found_range = True
                for i in range(range_open_paren_pos + 1, len(line_stripped)):  # Start after "range("
                    char = line_stripped[i]
                    range_expr += char
                    if char == '(':
                        paren_count += 1
                    elif char == ')':
                        paren_count -= 1
                        if paren_count == 0:
                            # Found the matching closing paren for range()
                            break
                
                # If we found a complete range expression and a statement, fix it
                if found_range and paren_count == 0 and statement:
                    # Check if there's leftover text after range_expr that should be part of range
                    range_expr_end_pos = range_start_pos + len(range_expr)
                    remaining_after_range = line_stripped[range_expr_end_pos:].strip()
                    
                    # If remaining text looks like range arguments (e.g., ", 0, -1)"), append it to range_expr
                    if remaining_after_range and re.match(r'^,\s*[^,)]+,\s*[^,)]+\)', remaining_after_range):
                        # Extract the range arguments
                        range_args_match = re.match(r'^,\s*([^,)]+),\s*([^,)]+)\)', remaining_after_range)
                        if range_args_match:
                            range_expr += remaining_after_range[:remaining_after_range.index(')') + 1]
                            remaining_after_range = remaining_after_range[remaining_after_range.index(')') + 1:].strip()
                    
                    # Clean up the statement - remove any trailing range arguments that got mixed in
                    statement_cleaned = statement
                    # Check if statement ends with something like ", 0, -1)" which suggests leftover range args
                    if re.search(r',\s*\d+,\s*-?\d+\)\s*$', statement_cleaned):
                        # Remove the trailing range arguments that got mixed into the statement
                        statement_cleaned = re.sub(r',\s*\d+,\s*-?\d+\)\s*$', '', statement_cleaned)
                    
                    fixed_lines.append(f'for {var} in {range_expr}:')
                    fixed_lines.append(f'    {statement_cleaned}')
                else:
                    # Try pattern3 as fallback
                    match_obj = re.match(pattern3, line_stripped)
                    if match_obj:
                        statement = match_obj.group(1).strip()
                        var = match_obj.group(2)
                        range_expr = match_obj.group(3)
                        fixed_lines.append(f'for {var} in {range_expr}:')
                        fixed_lines.append(f'    {statement}')
                    else:
                        fixed_lines.append(line)
            elif is_list_comprehension:
                # This is a list comprehension - leave it as-is (it's valid Python)
                fixed_lines.append(line)
            else:
                # Try pattern3 as fallback
                match_obj = re.match(pattern3, line_stripped)
                if match_obj:
                    statement = match_obj.group(1).strip()
                    var = match_obj.group(2)
                    range_expr = match_obj.group(3)
                    fixed_lines.append(f'for {var} in {range_expr}:')
                    fixed_lines.append(f'    {statement}')
                else:
                    # Check for for loop inside function call (handle multi-line)
                    # Join current line with previous lines to check for multi-line patterns
                    context_lines = fixed_lines[-3:] + [line] if len(fixed_lines) >= 3 else fixed_lines + [line]
                    context = '\n'.join(context_lines)
                    fixed_context = fix_for_in_function_call_multiline(context)
                    
                    if fixed_context != context:
                        # Pattern was fixed - replace the last few lines with the fixed version
                        # Remove the last few lines we checked
                        fixed_lines = fixed_lines[:-len(context_lines) + 1] if len(fixed_lines) >= len(context_lines) - 1 else []
                        # Add the fixed version (split back into lines)
                        fixed_lines.extend(fixed_context.split('\n'))
                    else:
                        fixed_lines.append(line)
        code = '\n'.join(fixed_lines)
        
        # Additional fix: Detect and fix "for" keyword appearing inside function call parentheses
        # This handles cases like: .reset_index(for i in range(...): ...)
        # We'll search for this pattern and restructure it
        def fix_for_inside_parentheses(code_str):
            # Pattern: find "for var in range" that appears after an opening parenthesis
            # This is a sign of malformed code
            lines = code_str.split('\n')
            result = []
            i = 0
            while i < len(lines):
                line = lines[i]
                # Check if this line or next lines contain "for" after an opening paren
                # Look ahead a few lines to catch multi-line issues
                lookahead = ' '.join(lines[i:min(i+5, len(lines))])
                
                # Pattern: .method(for var in range or method(for var in range
                if re.search(r'\(for\s+\w+\s+in\s+range', lookahead):
                    # Found malformed pattern - try to extract and fix
                    # Find the assignment statement before this
                    if i > 0:
                        # Look for assignment in previous lines
                        assignment_line = ''
                        for j in range(max(0, i-3), i):
                            if '=' in lines[j] and not lines[j].strip().startswith('#'):
                                assignment_line = lines[j]
                                break
                        
                        # Extract for loop details - match full range() call including all arguments
                        for_match = re.search(r'for\s+(\w+)\s+in\s+(range\([^)]+(?:,\s*[^)]+)*\))', lookahead)
                        if for_match and assignment_line:
                            var = for_match.group(1)
                            range_expr = for_match.group(2)  # Already complete with all arguments
                            
                            # Remove the malformed for loop from the code
                            # Find where it starts and ends
                            cleaned_lines = []
                            skip_until_paren = False
                            for k in range(i, min(i+10, len(lines))):
                                if k < len(lines):
                                    cleaned = re.sub(r'\(for\s+\w+\s+in\s+range[^)]*\):\s*', '(', lines[k])
                                    cleaned = re.sub(r'for\s+\w+\s+in\s+range[^)]*\):\s*', '', cleaned)
                                    if cleaned.strip() and not cleaned.strip().startswith('for'):
                                        cleaned_lines.append(cleaned)
                            
                            # Reconstruct as proper for loop
                            if cleaned_lines:
                                result.append(f'for {var} in {range_expr}:')
                                result.append(f'    {assignment_line}')
                                for cl in cleaned_lines:
                                    result.append(f'    {cl}')
                                i += len(cleaned_lines)
                                continue
                
                result.append(line)
                i += 1
            
            return '\n'.join(result)
        
        # Apply the fix - but skip if code is semicolon-separated (valid Python)
        # Only apply fix_for_inside_parentheses if code doesn't have semicolons
        # or if it's clearly malformed (for loop inside parentheses)
        if ';' not in code or not re.search(r'\(for\s+\w+\s+in\s+range', code):
            code = fix_for_inside_parentheses(code)
        
        # Clean up whitespace
        code = code.strip()
        
        return code
    
    def _validate_code(self, python_code: str) -> Dict[str, Any]:
        """
        Validate code before execution
        
        Returns:
            {"valid": bool, "error": str}
        """
        # Clean the code first (remove markdown, etc.)
        cleaned_code = self._clean_code(python_code)
        
        # Log the full cleaned code for debugging (first 1000 chars)
        logger.info(f"üîç Full cleaned code (first 1000 chars): {cleaned_code[:1000]}")
        logger.info(f"üîç Full cleaned code length: {len(cleaned_code)}")
        
        # Check if code is empty after cleaning
        if not cleaned_code or not cleaned_code.strip():
            return {"valid": False, "error": "Code is empty after cleaning"}
        
        # Check 1: No import statements
        if re.search(r'\bimport\s+\w+|from\s+\w+\s+import', cleaned_code):
            return {"valid": False, "error": "Import statements are not allowed"}
        
        # Check 2: No file operations
        dangerous_patterns = [
            r'\bopen\s*\(', r'\bread\s*\(', r'\bwrite\s*\(',
            r'__file__', r'__import__', r'eval\s*\(', r'exec\s*\(',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, cleaned_code):
                return {"valid": False, "error": f"Dangerous operation detected: {pattern}"}
        
        # Check 3: No system operations
        if re.search(r'\bos\.|sys\.|subprocess\.|shutil\.', cleaned_code):
            return {"valid": False, "error": "System operations are not allowed"}
        
        # Check 4: Basic syntax validation
        try:
            compile(cleaned_code, '<string>', 'exec')
        except SyntaxError as e:
            # Include the problematic code in error message
            error_line = getattr(e, 'lineno', 'unknown')
            error_text = getattr(e, 'text', '')
            code_preview = cleaned_code[:300] if len(cleaned_code) > 300 else cleaned_code
            return {
                "valid": False, 
                "error": f"Syntax error at line {error_line}: {str(e)}\nCode preview:\n{code_preview}"
            }
        
        # Debug: Log if df.loc was replaced with df.iloc
        if 'df.loc[' in python_code and 'df.iloc[' in cleaned_code:
            logger.info(f"üîß Converted df.loc to df.iloc in code cleaning")
        elif 'df.loc[' in python_code:
            logger.warning(f"‚ö†Ô∏è df.loc found in code but not converted to df.iloc")
            logger.warning(f"‚ö†Ô∏è Original code snippet: {python_code[:500]}")
            logger.warning(f"‚ö†Ô∏è Cleaned code snippet (first 500 chars): {cleaned_code[:500]}")
            logger.warning(f"‚ö†Ô∏è Cleaned code snippet (full length: {len(cleaned_code)}): {cleaned_code}")
            # Force replacement if it wasn't done
            if 'df.loc[' in cleaned_code:
                cleaned_code = cleaned_code.replace('df.loc[', 'df.iloc[')
                logger.info(f"üîß Force-converted remaining df.loc to df.iloc")
                logger.info(f"üîß After force conversion (first 500 chars): {cleaned_code[:500]}")
        
        return {"valid": True, "error": None, "cleaned_code": cleaned_code}
    
    def _extract_results(self, exec_globals: Dict, result_type: str) -> Any:
        """Extract results from execution environment"""
        if result_type == "single_value":
            # Single value result (SUM, AVERAGE, etc.)
            if 'result' in exec_globals and exec_globals['result'] is not None:
                return exec_globals['result']
            return None
        
        elif result_type == "dataframe":
            # DataFrame operation (filter, sort, etc.)
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        elif result_type == "new_column":
            # New column created
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        return None
    
    def _handle_name_error(self, error: NameError, python_code: str) -> str:
        """Handle NameError with helpful messages"""
        error_str = str(error)
        
        # Extract the missing name
        match = re.search(r"'(\w+)'", error_str)
        if match:
            missing_name = match.group(1)
            
            # Provide helpful suggestions
            suggestions = {
                'pandas': "Use 'pd' instead of 'pandas'",
                'numpy': "Use 'np' instead of 'numpy'",
                'DataFrame': "Use 'pd.DataFrame' instead of 'DataFrame'",
            }
            
            if missing_name in suggestions:
                return f"{error_str}. {suggestions[missing_name]}"
            
            return f"{error_str}. Available: df, pd, np, DateCleaner, TextCleaner, CurrencyCleaner, and standard Python functions"
        
        return str(error)
    
    def execute_multiple(self, operations: List[Dict]) -> Dict[str, Any]:
        """
        Execute multiple operations in sequence
        
        Args:
            operations: List of operation dicts with 'python_code' and 'description'
        
        Returns:
            Dict with execution summary
        """
        logger.info(f"üîç execute_multiple called with {len(operations)} operations")
        results = []
        successful = 0
        failed = 0
        
        for idx, operation in enumerate(operations):
            python_code = operation.get("python_code")
            description = operation.get("description", f"Operation {idx+1}")
            logger.info(f"üîç Processing operation {idx+1}/{len(operations)}: {description}")
            if not python_code:
                logger.warning(f"‚ö†Ô∏è Operation {idx+1} has no python_code, skipping")
                continue
            
            try:
                result = self.execute(python_code, operation)
                results.append(result)
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"Operation failed: {operation.get('description', 'Unknown')} - {str(e)}")
                # Raise to stop execution on first error
                raise
        
        return {
            "total": len(operations),
            "successful": successful,
            "failed": failed,
            "results": results,
            "final_df": self.df,
            "log": self.execution_log
        }
    
    def get_dataframe(self) -> pd.DataFrame:
        """Get current dataframe"""
        return self.df.copy()
    
    def get_result(self) -> Any:
        """Get last result"""
        return self.result
    
    def get_execution_log(self) -> List[str]:
        """Get execution log"""
        return self.execution_log.copy()
    
    def get_errors(self) -> List[str]:
        """Get errors"""
        return self.errors.copy()

