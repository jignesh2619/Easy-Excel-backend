"""
Python Executor

Robust executor for executing Python code generated by GPT-4.
Handles all data operations: formulas, cleaning, filtering, sorting, etc.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
from datetime import datetime, date, timedelta
import logging
import re
from services.cleaning.dates import DateCleaner
from services.cleaning.currency import CurrencyCleaner
from services.cleaning.text import TextCleaner

logger = logging.getLogger(__name__)


class PythonExecutor:
    """Robust Python code executor for Excel operations"""
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize executor with dataframe
        
        Args:
            df: DataFrame to operate on
        """
        self.df = df.copy()  # Work on copy
        self.original_df = df.copy()
        self.result = None
        self.execution_log: List[str] = []
        self.errors: List[str] = []
    
    def execute(self, python_code: str, operation_meta: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Execute Python code safely
        
        Args:
            python_code: Python code string to execute
            operation_meta: Optional metadata about the operation
        
        Returns:
            Dict with execution results
        """
        operation_meta = operation_meta or {}
        description = operation_meta.get("description", "Operation")
        result_type = operation_meta.get("result_type", "dataframe")
        
        # Step 1: Validate code
        validation_result = self._validate_code(python_code)
        if not validation_result["valid"]:
            error_msg = f"Code validation failed: {validation_result['error']}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Code validation failed for: {description}\nOriginal code: {python_code[:500]}")
            raise RuntimeError(error_msg)
        
        # Use cleaned code if available, otherwise use original
        code_to_execute = validation_result.get("cleaned_code", python_code)
        
        # Step 2: Prepare execution environment
        exec_globals = self._build_execution_environment()
        
        # Step 3: Execute code
        try:
            # Execute the cleaned code
            exec(code_to_execute, exec_globals)
            
            # Step 4: Extract results
            result = self._extract_results(exec_globals, result_type)
            
            # Step 5: Update dataframe
            if 'df' in exec_globals:
                self.df = exec_globals['df']
                # Ensure index is reset after operations
                if not self.df.index.equals(pd.RangeIndex(len(self.df))):
                    self.df = self.df.reset_index(drop=True)
            
            # Step 6: Store result
            if result is not None:
                self.result = result
            
            # Step 7: Log success
            self.execution_log.append(f"âœ“ {description}")
            logger.info(f"Successfully executed: {description}")
            
            return {
                "success": True,
                "result": result,
                "description": description,
                "rows_affected": len(self.df),
                "columns": list(self.df.columns)
            }
            
        except NameError as e:
            error_msg = self._handle_name_error(e, python_code)
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except KeyError as e:
            error_str = str(e)
            # Check if this is a drop operation trying to drop non-existent columns
            # If so, handle gracefully (columns might have been dropped already or never created)
            if "drop" in python_code.lower() and ("not found in axis" in error_str or "not found" in error_str.lower()):
                # Extract column names from error if possible
                import re
                # Try to extract column names from error message
                col_match = re.search(r"\[(.*?)\]", error_str)
                if col_match:
                    missing_cols = col_match.group(1)
                    logger.warning(f"âš ï¸ Drop operation: Columns {missing_cols} not found, skipping drop (may have been dropped already or never created)")
                    self.execution_log.append(f"âš  {description}: Columns {missing_cols} not found, skipping (safe to ignore)")
                    # Return success since this is a cleanup operation
                    return {
                        "success": True,
                        "result": None,
                        "description": description,
                        "rows_affected": len(self.df),
                        "columns": list(self.df.columns),
                        "warning": f"Columns {missing_cols} not found, operation skipped"
                    }
            
            error_msg = f"Column not found: {str(e)}. Available columns: {list(self.df.columns)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            raise RuntimeError(error_msg)
            
        except ValueError as e:
            error_str = str(e)
            # Check for the specific "Length of values does not match length of index" error
            if "Length of values" in error_str and "does not match length of index" in error_str:
                error_msg = f"Execution failed: {error_str}. This usually happens when trying to assign a list of values to a DataFrame row. When adding rows, create a dictionary with ONLY the columns you need, then use pd.concat([df, pd.DataFrame([new_row])], ignore_index=True). Example: new_row = {{'ColumnName': value}}; df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)"
            else:
                error_msg = f"Execution failed: {error_str}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except re.error as e:
            error_msg = f"Execution failed: Invalid regex pattern: {str(e)}. When removing or replacing special characters like *, ?, +, (, ), [, ], {{, }}, ^, $, |, \\, use regex=False. Example: df['Column'] = df['Column'].str.replace('*', '', regex=False)"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"Execution failed: {str(e)}"
            self.errors.append(error_msg)
            self.execution_log.append(f"âœ— {description}: {error_msg}")
            logger.error(f"Execution error: {error_msg}\nCode: {python_code[:200]}")
            raise RuntimeError(error_msg)
    
    def _build_execution_environment(self) -> Dict[str, Any]:
        """Build safe execution environment with all available resources"""
        return {
            # Data
            'df': self.df,
            'pd': pd,
            'np': np,
            'result': None,
            
            # Date/Time
            'datetime': datetime,
            'date': date,
            'timedelta': timedelta,
            
            # Cleaning utilities
            'DateCleaner': DateCleaner,
            'CurrencyCleaner': CurrencyCleaner,
            'TextCleaner': TextCleaner,
            
            # Math functions
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'sum': sum,
            'pow': pow,
            
            # Type conversion
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            
            # String functions
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'range': range,
            
            # Common operations
            'any': any,
            'all': all,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'reversed': reversed,
            
            # Pandas helpers
            'isna': pd.isna,
            'notna': pd.notna,
            'concat': pd.concat,
            'merge': pd.merge,
        }
    
    def _clean_code(self, python_code: str) -> str:
        """
        Clean code by removing markdown formatting and extra whitespace
        
        Args:
            python_code: Raw code string that might contain markdown
            
        Returns:
            Cleaned code string
        """
        code = python_code.strip()
        
        # Remove markdown code blocks (```python ... ```)
        if code.startswith('```'):
            # Find the closing ```
            lines = code.split('\n')
            # Remove first line if it's ```python or ```
            if lines[0].startswith('```'):
                lines = lines[1:]
            # Remove last line if it's ```
            if lines and lines[-1].strip() == '```':
                lines = lines[:-1]
            code = '\n'.join(lines)
        
        # Remove any remaining ``` markers
        code = re.sub(r'```[a-z]*\n?', '', code)
        
        # Clean up whitespace
        code = code.strip()
        
        return code
    
    def _validate_code(self, python_code: str) -> Dict[str, Any]:
        """
        Validate code before execution
        
        Returns:
            {"valid": bool, "error": str}
        """
        # Clean the code first (remove markdown, etc.)
        cleaned_code = self._clean_code(python_code)
        
        # Check if code is empty after cleaning
        if not cleaned_code or not cleaned_code.strip():
            return {"valid": False, "error": "Code is empty after cleaning"}
        
        # Check 1: No import statements
        if re.search(r'\bimport\s+\w+|from\s+\w+\s+import', cleaned_code):
            return {"valid": False, "error": "Import statements are not allowed"}
        
        # Check 2: No file operations
        dangerous_patterns = [
            r'\bopen\s*\(', r'\bread\s*\(', r'\bwrite\s*\(',
            r'__file__', r'__import__', r'eval\s*\(', r'exec\s*\(',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, cleaned_code):
                return {"valid": False, "error": f"Dangerous operation detected: {pattern}"}
        
        # Check 3: No system operations
        if re.search(r'\bos\.|sys\.|subprocess\.|shutil\.', cleaned_code):
            return {"valid": False, "error": "System operations are not allowed"}
        
        # Check 4: Basic syntax validation
        try:
            compile(cleaned_code, '<string>', 'exec')
        except SyntaxError as e:
            # Include the problematic code in error message
            error_line = getattr(e, 'lineno', 'unknown')
            error_text = getattr(e, 'text', '')
            code_preview = cleaned_code[:300] if len(cleaned_code) > 300 else cleaned_code
            return {
                "valid": False, 
                "error": f"Syntax error at line {error_line}: {str(e)}\nCode preview:\n{code_preview}"
            }
        
        return {"valid": True, "error": None, "cleaned_code": cleaned_code}
    
    def _extract_results(self, exec_globals: Dict, result_type: str) -> Any:
        """Extract results from execution environment"""
        if result_type == "single_value":
            # Single value result (SUM, AVERAGE, etc.)
            if 'result' in exec_globals and exec_globals['result'] is not None:
                return exec_globals['result']
            return None
        
        elif result_type == "dataframe":
            # DataFrame operation (filter, sort, etc.)
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        elif result_type == "new_column":
            # New column created
            if 'df' in exec_globals:
                return exec_globals['df']
            return self.df
        
        return None
    
    def _handle_name_error(self, error: NameError, python_code: str) -> str:
        """Handle NameError with helpful messages"""
        error_str = str(error)
        
        # Extract the missing name
        match = re.search(r"'(\w+)'", error_str)
        if match:
            missing_name = match.group(1)
            
            # Provide helpful suggestions
            suggestions = {
                'pandas': "Use 'pd' instead of 'pandas'",
                'numpy': "Use 'np' instead of 'numpy'",
                'DataFrame': "Use 'pd.DataFrame' instead of 'DataFrame'",
            }
            
            if missing_name in suggestions:
                return f"{error_str}. {suggestions[missing_name]}"
            
            return f"{error_str}. Available: df, pd, np, DateCleaner, TextCleaner, CurrencyCleaner, and standard Python functions"
        
        return str(error)
    
    def execute_multiple(self, operations: List[Dict]) -> Dict[str, Any]:
        """
        Execute multiple operations in sequence
        
        Args:
            operations: List of operation dicts with 'python_code' and 'description'
        
        Returns:
            Dict with execution summary
        """
        logger.info(f"ðŸ” execute_multiple called with {len(operations)} operations")
        results = []
        successful = 0
        failed = 0
        
        for idx, operation in enumerate(operations):
            python_code = operation.get("python_code")
            description = operation.get("description", f"Operation {idx+1}")
            logger.info(f"ðŸ” Processing operation {idx+1}/{len(operations)}: {description}")
            if not python_code:
                logger.warning(f"âš ï¸ Operation {idx+1} has no python_code, skipping")
                continue
            
            try:
                result = self.execute(python_code, operation)
                results.append(result)
                successful += 1
            except Exception as e:
                failed += 1
                logger.error(f"Operation failed: {operation.get('description', 'Unknown')} - {str(e)}")
                # Raise to stop execution on first error
                raise
        
        return {
            "total": len(operations),
            "successful": successful,
            "failed": failed,
            "results": results,
            "final_df": self.df,
            "log": self.execution_log
        }
    
    def get_dataframe(self) -> pd.DataFrame:
        """Get current dataframe"""
        return self.df.copy()
    
    def get_result(self) -> Any:
        """Get last result"""
        return self.result
    
    def get_execution_log(self) -> List[str]:
        """Get execution log"""
        return self.execution_log.copy()
    
    def get_errors(self) -> List[str]:
        """Get errors"""
        return self.errors.copy()

